<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.80.0" />

  <title> Pytorch Style Guide |  imlauzh</title>
  <meta name="description" content="A website built by Joseph Lau and host by Github pages.">
  <link rel="stylesheet" href="/blog/css/index.css">
  <link rel="stylesheet" href="/blog/css/classes.css">
  <link rel="canonical" href="/blog/posts/pytorch-style-guide/">
  <link rel="alternate" type="application/rss+xml" href="" title="imlauzh">
  
  
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">
  <link 
    rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" 
    integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" 
    crossorigin="anonymous">
  </link>
  <script 
    defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" 
    integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" 
    crossorigin="anonymous">
  </script>
  <script 
    defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" 
    integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" 
    crossorigin="anonymous" 
    onload="renderMathInElement(document.body);">
  </script>
</head>

<body>
  <header class="menus">
  

  <nav >
    
    <a href="/blog/"> Home</a>
    
    <a href="/blog/categories/"> Categories</a>
    
    <a href="/blog/tags/"> Tags</a>
    
    <a href="/blog/about/"> About</a>
    
    <a href="/blog/index.xml"> Subscribe</a>
    
  </nav>

  <nav class="fontawesome">
    
    <a href="https://github.com/imlauzh" target="_blank">
        <i title="GitHub" class="fab fa-github"></i>
    </a>
    
    
    <a href="/blog/index.xml" target="_blank">
        <i title="RSS" class="fas fa-rss"></i>
    </a>
    
  </nav>
  
  
  <div class="hidden description">A website built by Joseph Lau and host by Github pages.</div>
  
</header>

<article id="article">
  <header>
  
    <i class="fas fa-folder"></i>
    
    <a href="/blog/categories/reproduce">Reproduce</a>
    &nbsp;
    
  

    <h1 style="text-align: center;" >Pytorch Style Guide</h1>
    <div class="post-meta">
    
      <time datetime="2019-05-01T09:03:11Z">May 01, 2019</time> &nbsp; 
    

     &nbsp;

    
    
      <i class="far fa-eye"></i>
      <span id="/blog/posts/pytorch-style-guide/" class="leancloud_visitors" data-flag-title="Pytorch Style Guide">
          <span class="leancloud-visitors-count">  </span>
      </span> &nbsp;
    
    

    
      <i class="far fa-clock"></i>
      
      
      

      
        12 min
      
      55 s
      &nbsp;
    
    </div>
  </header>

  <h1 id="pytorch-style-guide">Pytorch Style Guide</h1>
<!-- raw HTML omitted -->
<blockquote>
<p>This is not an official style guide for PyTorch. This document summarizes best practices from more than a year of experience with deep learning using the PyTorch framework. Note that the learnings we share come mostly from a research and startup perspective.</p>
<p>This is an open project and other collaborators are highly welcomed to edit and improve the document.</p>
<p>You will find three main parts of this doc. First, a quick recap of best practices in Python, followed by some tips and recommendations using PyTorch. Finally, we share some insights and experiences using other frameworks which helped us generally improve our workflow.</p>
</blockquote>
<h2 id="we-recommend-using-python-36">We recommend using Python 3.6+</h2>
<p>From our experience we recommend using Python 3.6+ because of the following features which became very handy for clean and simple code:</p>
<ul>
<li><a href="https://medium.com/@ageitgey/learn-how-to-use-static-type-checking-in-python-3-6-in-10-minutes-12c86d72677b">Support for typing since Python 3.6.</a></li>
<li><a href="https://realpython.com/python-f-strings/">Support of f strings since Python 3.6</a></li>
</ul>
<h2 id="python-styleguide-recap">Python Styleguide recap</h2>
<p>We try to follow the Google Styleguide for Python.
Please refer to the well-documented  <a href="https://github.com/google/styleguide/blob/gh-pages/pyguide.md">style guide on python code provided by Google</a>.</p>
<p>We provide here a summary of the most commonly used rules:</p>
<h3 id="naming-conventions">Naming Conventions</h3>
<p><em>From 3.16.4</em></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Convention</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Packages &amp; Modules</td>
<td>lower_with_under</td>
<td>from <strong>prefetch_generator</strong> import BackgroundGenerator</td>
</tr>
<tr>
<td>Classes</td>
<td>CapWords</td>
<td>class <strong>DataLoader</strong></td>
</tr>
<tr>
<td>Constants</td>
<td>CAPS_WITH_UNDER</td>
<td><strong>BATCH_SIZE=16</strong></td>
</tr>
<tr>
<td>Instances</td>
<td>lower_with_under</td>
<td><strong>dataset</strong> = Dataset</td>
</tr>
<tr>
<td>Methods &amp; Functions</td>
<td>lower_with_under()</td>
<td>def <strong>visualize_tensor()</strong></td>
</tr>
<tr>
<td>Variables</td>
<td>lower_with_under</td>
<td><strong>background_color=&lsquo;Blue&rsquo;</strong></td>
</tr>
</tbody>
</table>
<h2 id="ides">IDEs</h2>
<h3 id="code-editors">Code Editors</h3>
<p>In general, we recommend the use of an IDE such as visual studio code or PyCharm. Whereas VS Code provides syntax highlighting and autocompletion in a relatively lightweight editor PyCharm has lots of advanced features for working with remote clusters.</p>
<h4 id="setting-up-pycharm-to-work-with-a-remote-machine">Setting up PyCharm to work with a Remote Machine</h4>
<ol>
<li>Login to your remote machine (AWS, Google etc.)</li>
<li>Create a new folder and a new virtual environment</li>
<li>In Pycharm (professional edition) in the project settings setup a remote interpreter</li>
<li>Configure the remote python interpreter (path to venv on AWS, Google etc.)</li>
<li>Configure the mapping of the code from your local machine to the remote machine</li>
</ol>
<p>If set up properly this allows you to do the following:</p>
<ul>
<li>Code on your local computer (notebook, desktop) wherever you want (offline, online)</li>
<li>Sync local code with your remote machine</li>
<li>Additional packages will be installed automatically on a remote machine</li>
<li>You don&rsquo;t need any dataset on your local machine</li>
<li>Run the code and debug on the remote machine as if it would be your local machine running the code</li>
</ul>
<h2 id="jupyter-notebook-vs-python-scripts">Jupyter Notebook vs Python Scripts</h2>
<p>In general, we recommend to use jupyter notebooks for initial exploration/ playing around with new models and code.
Python scripts should be used as soon as you want to train the model on a bigger dataset where also reproducibility is more important.</p>
<p><strong>Our recommended workflow:</strong></p>
<ol>
<li>Start with a jupyter notebook</li>
<li>Explore the data and models</li>
<li>Build your classes/ methods inside cells of the notebook</li>
<li>Move your code to python scripts</li>
<li>Train/ deploy on server</li>
</ol>
<table>
<thead>
<tr>
<th><strong>Jupyter Notebook</strong></th>
<th><strong>Python Scripts</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>+ Exploration</td>
<td>+ Running longer jobs without interruption</td>
</tr>
<tr>
<td>+ Debugging</td>
<td>+ Easy to track changes with git</td>
</tr>
<tr>
<td>- Can become a huge file</td>
<td>- Debugging mostly means rerunning the whole script</td>
</tr>
<tr>
<td>- Can be interrupted (don&rsquo;t use for long training)</td>
<td></td>
</tr>
<tr>
<td>- Prone to errors and become a mess</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="libraries">Libraries</h2>
<p>Commonly used libraries:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Used for</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://pytorch.org/">torch</a></td>
<td>Base Framework for working with neural networks</td>
<td>creating tensors, networks and training them using backprop</td>
</tr>
<tr>
<td><a href="https://pytorch.org/docs/stable/torchvision">torchvision</a></td>
<td>todo</td>
<td>data preprocessing, augmentation, postprocessing</td>
</tr>
<tr>
<td><a href="https://pillow.readthedocs.io/en/stable/">Pillow (PIL)</a></td>
<td>Python Imaging Library</td>
<td>Loading images and storing them</td>
</tr>
<tr>
<td><a href="https://www.numpy.org/">Numpy</a></td>
<td>Package for scientific computing with Python</td>
<td>Data preprocessing &amp; postprocessing</td>
</tr>
<tr>
<td><a href="https://pypi.org/project/prefetch_generator/">prefetch_generator</a></td>
<td>Library for background processing</td>
<td>Loading next batch in background during computation</td>
</tr>
<tr>
<td><a href="https://github.com/tqdm/tqdm">tqdm</a></td>
<td>Progress bar</td>
<td>Progress during training of each epoch</td>
</tr>
<tr>
<td><a href="https://github.com/sksq96/pytorch-summary">torchsummary</a></td>
<td>Keras summary for PyTorch</td>
<td>Displays network, it&rsquo;s parameters and sizes at each layer</td>
</tr>
<tr>
<td><a href="https://github.com/lanpa/tensorboardX">tensorboardx</a></td>
<td>Tensorboard without tensorflow</td>
<td>Logging experiments and showing them in tensorboard</td>
</tr>
</tbody>
</table>
<h2 id="file-organization">File Organization</h2>
<p>Don&rsquo;t put all layers and models into the same file. A best practice is to separate the final networks into a separate file (<em>networks.py</em>) and keep the layers, losses, and ops in respective files (<em>layers.py</em>, <em>losses.py</em>, <em>ops.py</em>). The finished model (composed of one or multiple networks) should be reference in a file with its name (e.g. <em>yolov3.py</em>, <em>DCGAN.py</em>)</p>
<p>The main routine, respective the train and test scripts should only import from the file having the model&rsquo;s name.</p>
<h2 id="building-a-neural-network-in-pytorch">Building a Neural Network in PyTorch</h2>
<p>We recommend breaking up the network into its smaller reusable pieces. A network is a <strong>nn.Module</strong> consisting of operations or other <strong>nn.Module</strong>s as building blocks. Loss functions are also <strong>nn.Module</strong> and can, therefore, be directly integrated into the network.</p>
<p>A class inheriting from <strong>nn.Module</strong> must have a <em>forward</em> method implementing the forward pass of the respective layer or operation.</p>
<p>A <strong>nn.module</strong> can be used on input data using <strong>self.net(input)</strong>. This simply uses the <em><strong>call</strong>()</em> method of the object to feed the input through the module.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">output <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>net(input)
</code></pre></div><h3 id="a-simple-network-in-pytorch">A Simple Network in PyTorch</h3>
<p>Use the following pattern for simple networks with a single input and single output:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ConvBlock</span>(nn<span style="color:#f92672">.</span>Module):
    <span style="color:#66d9ef">def</span> __init__(self):
        super(ConvBlock, self)<span style="color:#f92672">.</span>__init__()
        block <span style="color:#f92672">=</span> [nn<span style="color:#f92672">.</span>Conv2d(<span style="color:#f92672">...</span>)]
        block <span style="color:#f92672">+=</span> [nn<span style="color:#f92672">.</span>ReLU()]
        block <span style="color:#f92672">+=</span> [nn<span style="color:#f92672">.</span>BatchNorm2d(<span style="color:#f92672">...</span>)]
        self<span style="color:#f92672">.</span>block <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>Sequential(<span style="color:#f92672">*</span>block)
    
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, x):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>block(x)

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SimpleNetwork</span>(nn<span style="color:#f92672">.</span>Module):
    <span style="color:#66d9ef">def</span> __init__(self, num_resnet_blocks<span style="color:#f92672">=</span><span style="color:#ae81ff">6</span>):
        super(SimpleNetwork, self)<span style="color:#f92672">.</span>__init__()
        <span style="color:#75715e"># here we add the individual layers</span>
        layers <span style="color:#f92672">=</span> [ConvBlock(<span style="color:#f92672">...</span>)]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(num_resnet_blocks):
            layers <span style="color:#f92672">+=</span> [ResBlock(<span style="color:#f92672">...</span>)]
        self<span style="color:#f92672">.</span>net <span style="color:#f92672">=</span> nn<span style="color:#f92672">.</span>Sequential(<span style="color:#f92672">*</span>layers)
    
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, x):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>net(x)
</code></pre></div><p>Note the following:</p>
<ul>
<li>We reuse simple, recurrent building blocks such as <em>ConvBlock</em> which consists of the same recurrent pattern of (convolution, activation, normalization) and put them into a separate nn.Module</li>
<li>We build up a list of desired layers and finally turn them into a model using <em>nn.Sequential()</em>. We use the * operator before the list object to unwrap it.</li>
<li>In the forward pass we just run the input through the model</li>
</ul>
<h3 id="a-network-with-skip-connections-in-pytorch">A Network with skip connections in PyTorch</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResnetBlock</span>(nn<span style="color:#f92672">.</span>Module):
    <span style="color:#66d9ef">def</span> __init__(self, dim, padding_type, norm_layer, use_dropout, use_bias):
        super(ResnetBlock, self)<span style="color:#f92672">.</span>__init__()
        self<span style="color:#f92672">.</span>conv_block <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>build_conv_block(<span style="color:#f92672">...</span>)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_conv_block</span>(self, <span style="color:#f92672">...</span>):
        conv_block <span style="color:#f92672">=</span> []

        conv_block <span style="color:#f92672">+=</span> [nn<span style="color:#f92672">.</span>Conv2d(<span style="color:#f92672">...</span>),
                       norm_layer(<span style="color:#f92672">...</span>),
                       nn<span style="color:#f92672">.</span>ReLU()]
        <span style="color:#66d9ef">if</span> use_dropout:
            conv_block <span style="color:#f92672">+=</span> [nn<span style="color:#f92672">.</span>Dropout(<span style="color:#f92672">...</span>)]
            
        conv_block <span style="color:#f92672">+=</span> [nn<span style="color:#f92672">.</span>Conv2d(<span style="color:#f92672">...</span>),
                       norm_layer(<span style="color:#f92672">...</span>)]

        <span style="color:#66d9ef">return</span> nn<span style="color:#f92672">.</span>Sequential(<span style="color:#f92672">*</span>conv_block)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, x):
        out <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>conv_block(x)
        <span style="color:#66d9ef">return</span> out
</code></pre></div><p>Here the skip connection of a <em>ResNet block</em> has been implemented directly in the forward pass. PyTorch allows for dynamic operations during the forward pass.</p>
<h3 id="a-network-with-multiple-outputs-in-pytorch">A Network with multiple outputs in PyTorch</h3>
<p>For a network requiring multiple outputs, such as building a perceptual loss using a pretrained VGG network we use the following pattern:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Vgg19</span>(torch<span style="color:#f92672">.</span>nn<span style="color:#f92672">.</span>Module):
  <span style="color:#66d9ef">def</span> __init__(self, requires_grad<span style="color:#f92672">=</span>False):
    super(Vgg19, self)<span style="color:#f92672">.</span>__init__()
    vgg_pretrained_features <span style="color:#f92672">=</span> models<span style="color:#f92672">.</span>vgg19(pretrained<span style="color:#f92672">=</span>True)<span style="color:#f92672">.</span>features
    self<span style="color:#f92672">.</span>slice1 <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>nn<span style="color:#f92672">.</span>Sequential()
    self<span style="color:#f92672">.</span>slice2 <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>nn<span style="color:#f92672">.</span>Sequential()
    self<span style="color:#f92672">.</span>slice3 <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>nn<span style="color:#f92672">.</span>Sequential()

    <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">7</span>):
        self<span style="color:#f92672">.</span>slice1<span style="color:#f92672">.</span>add_module(str(x), vgg_pretrained_features[x])
    <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">21</span>):
        self<span style="color:#f92672">.</span>slice2<span style="color:#f92672">.</span>add_module(str(x), vgg_pretrained_features[x])
    <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">30</span>):
        self<span style="color:#f92672">.</span>slice3<span style="color:#f92672">.</span>add_module(str(x), vgg_pretrained_features[x])
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> requires_grad:
        <span style="color:#66d9ef">for</span> param <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>parameters():
            param<span style="color:#f92672">.</span>requires_grad <span style="color:#f92672">=</span> False

  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, x):
    h_relu1 <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>slice1(x)
    h_relu2 <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>slice2(h_relu1)        
    h_relu3 <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>slice3(h_relu2)        
    out <span style="color:#f92672">=</span> [h_relu1, h_relu2, h_relu3]
    <span style="color:#66d9ef">return</span> out
</code></pre></div><p>Note here the following:</p>
<ul>
<li>We use a pretrained model provided by <em>torchvision</em>.</li>
<li>We split up the network into three slices. Each slice consists of layers from the pretrained model.</li>
<li>We <em>freeze</em> the network by setting <em>requires_grad = False</em></li>
<li>We return a list with the three outputs of our slices</li>
</ul>
<h2 id="custom-loss">Custom Loss</h2>
<p>Even if PyTorch already has a lot of of standard loss function it might be necessary sometimes to create your own loss function. For this, create a separate file <code>losses.py</code> and extend the <code>nn.Module</code> class to create your custom loss function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomLoss</span>(torch<span style="color:#f92672">.</span>nn<span style="color:#f92672">.</span>Module):
    
    <span style="color:#66d9ef">def</span> __init__(self):
        super(CustomLoss,self)<span style="color:#f92672">.</span>__init__()
        
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self,x,y):
        loss <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>mean((x <span style="color:#f92672">-</span> y)<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>)
        <span style="color:#66d9ef">return</span> loss
</code></pre></div><h2 id="recommended-code-structure-for-training-your-model">Recommended code structure for training your model</h2>
<p>Note that we used the following patterns:</p>
<ul>
<li>We use <em>BackgroundGenerator</em> from <em>prefetch_generator</em> to load next batches in background</li>
<li>We use tqdm to monitor training progress and show the <em>compute efficiency</em>. This helps us find bottlenecks in our data loading pipeline.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># import statements</span>
<span style="color:#f92672">import</span> torch
<span style="color:#f92672">import</span> torch.nn <span style="color:#f92672">as</span> nn
<span style="color:#f92672">from</span> torch.utils <span style="color:#f92672">import</span> data
<span style="color:#f92672">...</span>

<span style="color:#75715e"># set flags / seeds</span>
torch<span style="color:#f92672">.</span>backends<span style="color:#f92672">.</span>cudnn<span style="color:#f92672">.</span>benchmark <span style="color:#f92672">=</span> True
np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">1</span>)
torch<span style="color:#f92672">.</span>manual_seed(<span style="color:#ae81ff">1</span>)
torch<span style="color:#f92672">.</span>cuda<span style="color:#f92672">.</span>manual_seed(<span style="color:#ae81ff">1</span>)
<span style="color:#f92672">...</span>

<span style="color:#75715e"># Start with main code</span>
<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    <span style="color:#75715e"># argparse for additional flags for experiment</span>
    parser <span style="color:#f92672">=</span> argparse<span style="color:#f92672">.</span>ArgumentParser(description<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Train a network for ...&#34;</span>)
    <span style="color:#f92672">...</span>
    opt <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span>parse_args() 
    
    <span style="color:#75715e"># add code for datasets (we always use train and validation/ test set)</span>
    data_transforms <span style="color:#f92672">=</span> transforms<span style="color:#f92672">.</span>Compose([
        transforms<span style="color:#f92672">.</span>Resize((opt<span style="color:#f92672">.</span>img_size, opt<span style="color:#f92672">.</span>img_size)),
        transforms<span style="color:#f92672">.</span>RandomHorizontalFlip(),
        transforms<span style="color:#f92672">.</span>ToTensor(),
        transforms<span style="color:#f92672">.</span>Normalize((<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>), (<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>))
    ])
    
    train_dataset <span style="color:#f92672">=</span> datasets<span style="color:#f92672">.</span>ImageFolder(
        root<span style="color:#f92672">=</span>os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>join(opt<span style="color:#f92672">.</span>path_to_data, <span style="color:#e6db74">&#34;train&#34;</span>),
        transform<span style="color:#f92672">=</span>data_transforms)
    train_data_loader <span style="color:#f92672">=</span> data<span style="color:#f92672">.</span>DataLoader(train_dataset, <span style="color:#f92672">...</span>)
    
    test_dataset <span style="color:#f92672">=</span> datasets<span style="color:#f92672">.</span>ImageFolder(
        root<span style="color:#f92672">=</span>os<span style="color:#f92672">.</span>path<span style="color:#f92672">.</span>join(opt<span style="color:#f92672">.</span>path_to_data, <span style="color:#e6db74">&#34;test&#34;</span>),
        transform<span style="color:#f92672">=</span>data_transforms)
    test_data_loader <span style="color:#f92672">=</span> data<span style="color:#f92672">.</span>DataLoader(test_dataset <span style="color:#f92672">...</span>)
    <span style="color:#f92672">...</span>
    
    <span style="color:#75715e"># instantiate network (which has been imported from *networks.py*)</span>
    net <span style="color:#f92672">=</span> MyNetwork(<span style="color:#f92672">...</span>)
    <span style="color:#f92672">...</span>
    
    <span style="color:#75715e"># create losses (criterion in pytorch)</span>
    criterion_L1 <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>nn<span style="color:#f92672">.</span>L1Loss()
    <span style="color:#f92672">...</span>
    
    <span style="color:#75715e"># if running on GPU and we want to use cuda move model there</span>
    use_cuda <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>cuda<span style="color:#f92672">.</span>is_available()
    <span style="color:#66d9ef">if</span> use_cuda:
        net <span style="color:#f92672">=</span> net<span style="color:#f92672">.</span>cuda()
        <span style="color:#f92672">...</span>
    
    <span style="color:#75715e"># create optimizers</span>
    optim <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>optim<span style="color:#f92672">.</span>Adam(net<span style="color:#f92672">.</span>parameters(), lr<span style="color:#f92672">=</span>opt<span style="color:#f92672">.</span>lr)
    <span style="color:#f92672">...</span>
    
    <span style="color:#75715e"># load checkpoint if needed/ wanted</span>
    start_n_iter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    start_epoch <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">if</span> opt<span style="color:#f92672">.</span>resume:
        ckpt <span style="color:#f92672">=</span> load_checkpoint(opt<span style="color:#f92672">.</span>path_to_checkpoint) <span style="color:#75715e"># custom method for loading last checkpoint</span>
        net<span style="color:#f92672">.</span>load_state_dict(ckpt[<span style="color:#e6db74">&#39;net&#39;</span>])
        start_epoch <span style="color:#f92672">=</span> ckpt[<span style="color:#e6db74">&#39;epoch&#39;</span>]
        start_n_iter <span style="color:#f92672">=</span> ckpt[<span style="color:#e6db74">&#39;n_iter&#39;</span>]
        optim<span style="color:#f92672">.</span>load_state_dict(ckpt[<span style="color:#e6db74">&#39;optim&#39;</span>])
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;last checkpoint restored&#34;</span>)
        <span style="color:#f92672">...</span>
        
    <span style="color:#75715e"># if we want to run experiment on multiple GPUs we move the models there</span>
    net <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>nn<span style="color:#f92672">.</span>DataParallel(net)
    <span style="color:#f92672">...</span>
    
    <span style="color:#75715e"># typically we use tensorboardX to keep track of experiments</span>
    writer <span style="color:#f92672">=</span> SummaryWriter(<span style="color:#f92672">...</span>)
    
    <span style="color:#75715e"># now we start the main loop</span>
    n_iter <span style="color:#f92672">=</span> start_n_iter
    <span style="color:#66d9ef">for</span> epoch <span style="color:#f92672">in</span> range(start_epoch, opt<span style="color:#f92672">.</span>epochs):
        <span style="color:#75715e"># set models to train mode</span>
        net<span style="color:#f92672">.</span>train()
        <span style="color:#f92672">...</span>
        
        <span style="color:#75715e"># use prefetch_generator and tqdm for iterating through data</span>
        pbar <span style="color:#f92672">=</span> tqdm(enumerate(BackgroundGenerator(train_data_loader, <span style="color:#f92672">...</span>)),
                    total<span style="color:#f92672">=</span>len(train_data_loader))
        start_time <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
        
        <span style="color:#75715e"># for loop going through dataset</span>
        <span style="color:#66d9ef">for</span> i, data <span style="color:#f92672">in</span> pbar:
            <span style="color:#75715e"># data preparation</span>
            img, label <span style="color:#f92672">=</span> data
            <span style="color:#66d9ef">if</span> use_cuda:
                img <span style="color:#f92672">=</span> img<span style="color:#f92672">.</span>cuda()
                label <span style="color:#f92672">=</span> label<span style="color:#f92672">.</span>cuda()
            <span style="color:#f92672">...</span>
            
            <span style="color:#75715e"># It&#39;s very good practice to keep track of preparation time and computation time using tqdm to find any issues in your dataloader</span>
            prepare_time <span style="color:#f92672">=</span> start_time<span style="color:#f92672">-</span>time<span style="color:#f92672">.</span>time()
            
            <span style="color:#75715e"># forward and backward pass</span>
            optim<span style="color:#f92672">.</span>zero_grad()
            <span style="color:#f92672">...</span>
            loss<span style="color:#f92672">.</span>backward()
            optim<span style="color:#f92672">.</span>step()
            <span style="color:#f92672">...</span>
            
            <span style="color:#75715e"># udpate tensorboardX</span>
            writer<span style="color:#f92672">.</span>add_scalar(<span style="color:#f92672">...</span>, n_iter)
            <span style="color:#f92672">...</span>
            
            <span style="color:#75715e"># compute computation time and *compute_efficiency*</span>
            process_time <span style="color:#f92672">=</span> start_time<span style="color:#f92672">-</span>time<span style="color:#f92672">.</span>time()<span style="color:#f92672">-</span>prepare_time
            pbar<span style="color:#f92672">.</span>set_description(<span style="color:#e6db74">&#34;Compute efficiency: {:.2f}, epoch: {}/{}:&#34;</span><span style="color:#f92672">.</span>format(
                process_time<span style="color:#f92672">/</span>(process_time<span style="color:#f92672">+</span>prepare_time), epoch, opt<span style="color:#f92672">.</span>epochs))
            start_time <span style="color:#f92672">=</span> time<span style="color:#f92672">.</span>time()
            
        <span style="color:#75715e"># maybe do a test pass every x epochs</span>
        <span style="color:#66d9ef">if</span> epoch <span style="color:#f92672">%</span> x <span style="color:#f92672">==</span> x<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
            <span style="color:#75715e"># bring models to evaluation mode</span>
            net<span style="color:#f92672">.</span>eval()
            <span style="color:#f92672">...</span>
            <span style="color:#75715e">#do some tests</span>
            pbar <span style="color:#f92672">=</span> tqdm(enumerate(BackgroundGenerator(test_data_loader, <span style="color:#f92672">...</span>)),
                    total<span style="color:#f92672">=</span>len(test_data_loader)) 
            <span style="color:#66d9ef">for</span> i, data <span style="color:#f92672">in</span> pbar:
                <span style="color:#f92672">...</span>
                
            <span style="color:#75715e"># save checkpoint if needed</span>
            <span style="color:#f92672">...</span>
</code></pre></div><h2 id="training-on-multiple-gpus-in-pytorch">Training on Multiple GPUs in PyTorch</h2>
<p>There are two distinct patterns in PyTorch to use multiple GPUs for training.
From our experience both patterns are valid. The first one results however in nicer and less code. The second one seems to have a slight performance advantage due to less communication between the GPUs. <a href="https://discuss.pytorch.org/t/how-to-best-use-dataparallel-with-multiple-models/39289">I asked a question in the official PyTorch forum about the two approaches here</a></p>
<h3 id="split-up-the-batch-input-of-each-network">Split up the batch input of each network</h3>
<p>The most common one is to simply split up the batches of all <em>networks</em> to the individual GPUs.</p>
<blockquote>
<p>A model running on 1 GPU with batch size 64 would, therefore, run on 2 GPUs with each a batch size of 32. This can be done automatically by wrapping the model by <strong>nn.DataParallel(model)</strong>.</p>
</blockquote>
<h3 id="pack-all-networks-in-a-super-network-and-split-up-input-batch">Pack all networks in a <em>super</em> network and split up input batch</h3>
<p>This pattern is less commonly used. A repository implemnting this approach is shown here in the <a href="https://github.com/NVIDIA/pix2pixHD">pix2pixHD implementation by Nvidia</a></p>
<h2 id="dos-and-donts">Do&rsquo;s and Don&rsquo;t&rsquo;s</h2>
<h3 id="avoid-numpy-code-in-the-forward-method-of-a-nnmodule">Avoid Numpy Code in the forward method of a nn.Module</h3>
<p>Numpy runs on the CPU and is slower than torch code. Since torch has been developed with being similar to numpy in mind most numpy functions are supported by PyTorch already.</p>
<h3 id="separate-the-dataloader-from-the-main-code">Separate the DataLoader from the main Code</h3>
<p>The data loading pipeline should be independent of your main training code. PyTorch uses background workers for loading the data more efficiently and without disturbing the main training process.</p>
<h3 id="dont-log-results-in-every-step">Don&rsquo;t log results in every step</h3>
<p>Typically we train our models for thousands of steps. Therefore, it is enough to log loss and other results every n&rsquo;th step to reduce the overhead. Especially, saving intermediary results as images can be costly during training.</p>
<h3 id="use-command-line-arguments">Use Command-line Arguments</h3>
<p>It&rsquo;s very handy to use command-line arguments to set parameters during code execution (<em>batch size</em>, <em>learning rate</em>, etc). An easy way to keep track of the arguments for an experiment is by just printing the dictionary received from <em>parse_args</em>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">...</span>
<span style="color:#75715e"># saves arguments to config.txt file</span>
opt <span style="color:#f92672">=</span> parser<span style="color:#f92672">.</span>parse_args()
<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;config.txt&#34;</span>, <span style="color:#e6db74">&#34;w&#34;</span>) <span style="color:#66d9ef">as</span> f:
    f<span style="color:#f92672">.</span>write(opt<span style="color:#f92672">.</span>__str__())
<span style="color:#f92672">...</span>
</code></pre></div><h3 id="use-detach-to-free-tensors-from-the-graph-if-possible">Use <strong>.detach()</strong> to free tensors from the graph if possible</h3>
<p>PyTorch keeps track of of all operations involving tensors for automatic differentiation. Use <strong>.detach()</strong> to prevent recording of unnecessary operations.</p>
<h3 id="use-item-for-printing-scalar-tensors">Use <strong>.item()</strong> for printing scalar tensors</h3>
<p>You can print variables directly, however it&rsquo;s recommended to use <strong>variable.detach()</strong> or <strong>variable.item()</strong>. In earlier PyTorch versions &lt; 0.4 you have to use <strong>.data</strong> to access the tensor of a variable.</p>
<h3 id="use-the-call-method-instead-of-forward-on-a-nnmodule">Use the call method instead of forward on a <strong>nn.Module</strong></h3>
<p>The two ways are not identical as pointed out in one of the issues <a href="https://github.com/IgorSusmelj/pytorch-styleguide/issues/3">here</a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">output <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>net<span style="color:#f92672">.</span>forward(input)
<span style="color:#75715e"># they are not equal!</span>
output <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>net(input)
</code></pre></div><h2 id="faq">FAQ</h2>
<ol>
<li>How to keep my experiments reproducible?</li>
</ol>
<blockquote>
<p>We recommend setting the following seeds at the beginning of your code:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">1</span>)
torch<span style="color:#f92672">.</span>manual_seed(<span style="color:#ae81ff">1</span>)
torch<span style="color:#f92672">.</span>cuda<span style="color:#f92672">.</span>manual_seed(<span style="color:#ae81ff">1</span>)
</code></pre></div><ol start="2">
<li>How to improve training and inference speed further?</li>
</ol>
<blockquote>
<p>On Nvidia GPUs you can add the following line at the beginning of our code. This will allow the cuda backend to optimize your graph during its first execution. However, be aware that if you change the network input/output tensor size the graph will be optimized each time a change occurs. This can lead to very slow runtime and out of memory errors. Only set this flag if your input and output have always the same shape. Usually, this results in an improvement of about 20%.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">torch<span style="color:#f92672">.</span>backends<span style="color:#f92672">.</span>cudnn<span style="color:#f92672">.</span>benchmark <span style="color:#f92672">=</span> True
</code></pre></div><ol start="3">
<li>What is a good value for compute efficiency using your tqdm + prefetch_generator pattern?</li>
</ol>
<blockquote>
<p>It depends on the machine used, the preprocessing pipeline and the network size. Running on a SSD on a 1080Ti GPU we see a compute efficiency of almost 1.0 which is an ideal scenario. If shallow (small) networks or a slow harddisk is used the number may drop to around 0.1-0.2 depending on your setup.</p>
</blockquote>
<ol start="4">
<li>How can I have a batch size &gt; 1 even though I don&rsquo;t have enough memory?</li>
</ol>
<blockquote>
<p>In PyTorch we can implement very easily virtual batch sizes. We just prevent the optimizer from making an update of the parameters and sum up the gradients for <em>batch_size</em> cycles.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">...</span>
<span style="color:#75715e"># in the main loop</span>
out <span style="color:#f92672">=</span> net(input)
loss <span style="color:#f92672">=</span> criterion(out, label)
<span style="color:#75715e"># we just call backward to sum up gradients but don&#39;t perform step here</span>
loss<span style="color:#f92672">.</span>backward() 
total_loss <span style="color:#f92672">+=</span> loss<span style="color:#f92672">.</span>item() <span style="color:#f92672">/</span> batch_size
<span style="color:#66d9ef">if</span> n_iter <span style="color:#f92672">%</span> batch_size <span style="color:#f92672">==</span> batch_size<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
    <span style="color:#75715e"># here we perform out optimization step using a virtual batch size</span>
    optim<span style="color:#f92672">.</span>step()
    optim<span style="color:#f92672">.</span>zero_grad()
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Total loss: &#39;</span>, total_loss)
    total_loss <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>
<span style="color:#f92672">...</span>
</code></pre></div><ol start="5">
<li>How can I adjust the learning rate during training?</li>
</ol>
<blockquote>
<p>We can access the learning rate directly using the instantiated optimizer as shown here:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">...</span>
<span style="color:#66d9ef">for</span> param_group <span style="color:#f92672">in</span> optim<span style="color:#f92672">.</span>param_groups:
    old_lr <span style="color:#f92672">=</span> param_group[<span style="color:#e6db74">&#39;lr&#39;</span>]
    new_lr <span style="color:#f92672">=</span> old_lr <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.1</span>
    param_group[<span style="color:#e6db74">&#39;lr&#39;</span>] <span style="color:#f92672">=</span> new_lr
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Updated lr from {} to {}&#39;</span><span style="color:#f92672">.</span>format(old_lr, new_lr))
<span style="color:#f92672">...</span>
</code></pre></div><ol start="6">
<li>How to use a pretrained model as a loss (non backprop) during training</li>
</ol>
<blockquote>
<p>If you want to use a pretrained model such as VGG to compute a loss but not train it (e.g. Perceptual loss in style-transfer/ GANs/ Auto-encoder) you can use the following pattern:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">...</span>
<span style="color:#75715e"># instantiate the model</span>
pretrained_VGG <span style="color:#f92672">=</span> VGG19(<span style="color:#f92672">...</span>)

<span style="color:#75715e"># disable gradients (prevent training)</span>
<span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> pretrained_VGG<span style="color:#f92672">.</span>parameters():  <span style="color:#75715e"># reset requires_grad</span>
    p<span style="color:#f92672">.</span>requires_grad <span style="color:#f92672">=</span> False
<span style="color:#f92672">...</span>
<span style="color:#75715e"># you don&#39;t have to use the no_grad() namespace but can just run the model</span>
<span style="color:#75715e"># no gradients will be computed for the VGG model</span>
out_real <span style="color:#f92672">=</span> pretrained_VGG(input_a)
out_fake <span style="color:#f92672">=</span> pretrained_VGG(input_b)
loss <span style="color:#f92672">=</span> any_criterion(out_real, out_fake)
<span style="color:#f92672">...</span>
</code></pre></div><ol start="7">
<li>Why do we use <em>.train()</em> and <em>.eval()</em> in PyTorch?</li>
</ol>
<blockquote>
<p>Those methods are used to set layers such as <strong>BatchNorm2d</strong> or <strong>Dropout2d</strong> from training to inference mode. Every module which inherits from <strong>nn.Module</strong> has an attribute called <em>isTraining</em>. <strong>.eval()</strong> and <strong>.train()</strong> just simply sets this attribute to True/ False. For more information of how this method is implemented please have a look at <a href="https://pytorch.org/docs/stable/_modules/torch/nn/modules/module.html">the module code in PyTorch</a></p>
</blockquote>
<ol start="8">
<li>My model uses lots of memory during Inference/ How to run a model properly for inference in PyTorch?</li>
</ol>
<blockquote>
<p>Make sure that no gradients get computed and stored during your code execution. You can simply use the following pattern to assure that:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">with</span> torch<span style="color:#f92672">.</span>no_grad():
    <span style="color:#75715e"># run model here</span>
    out_tensor <span style="color:#f92672">=</span> net(in_tensor)
</code></pre></div><ol start="9">
<li>How to fine-tune a pretrained model?</li>
</ol>
<blockquote>
<p>In PyTorch you can freeze layers. This will prevent them from being updated during an optimization step.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#75715e"># you can freeze whole modules using</span>
<span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> pretrained_VGG<span style="color:#f92672">.</span>parameters():  <span style="color:#75715e"># reset requires_grad</span>
    p<span style="color:#f92672">.</span>requires_grad <span style="color:#f92672">=</span> False

</code></pre></div><ol start="10">
<li>When to use <strong>Variable(&hellip;)</strong>?</li>
</ol>
<blockquote>
<p>Since PyTorch 0.4 *<em>Variable</em> and <strong>Tensor</strong> have been merged. We don&rsquo;t have to explicitly create a <strong>Variable</strong> object anymore.</p>
</blockquote>
<ol start="11">
<li>Is PyTorch on C++ faster then using Python?</li>
</ol>
<blockquote>
<p>C++ version is about 10% faster</p>
</blockquote>
<ol start="12">
<li>Can TorchScript / JIT speed up my code?</li>
</ol>
<blockquote>
<p>Todo&hellip;</p>
</blockquote>
<ol start="13">
<li>Is PyTorch code using <strong>cudnn.benchmark=True</strong> faster?</li>
</ol>
<blockquote>
<p>From our experience you can gain about 20% speed-up. But the first time you run your model it takes quite some time to 
build the optimized graph. In some cases (loops in forward pass, no fixed input shape, if/else in forward, etc.) this flag might
result in <em>out of memory</em> or other errors.</p>
</blockquote>
<ol start="14">
<li>How to use multiple GPUs for training?</li>
</ol>
<blockquote>
<p>Todo&hellip;</p>
</blockquote>
<ol start="15">
<li>How does <strong>.detach()</strong> work in PyTorch?</li>
</ol>
<blockquote>
<p>If frees a tensor from a computation graph. A nice illustration is shown <a href="http://www.bnikolic.co.uk/blog/pytorch-detach.html">here</a></p>
</blockquote>

  
  <footer>
    <hr>
    
    <div class="post-tags">
    
      <i class="fas fa-tags"></i>
      
        <a href="/blog/tags/python">Python</a>
        &nbsp;
      
        <a href="/blog/tags/style-guide">Style Guide</a>
        &nbsp;
      
    
    </div>
  </footer>
  

  

<div class="releated-post">
  <h3>Related Posts</h3>
  
  <i class="fas fa-paperclip"></i>
  <a href="/blog/posts/google-python-style-guide/">Google Python Style Guide</a>
  <br>
  
  <i class="fas fa-paperclip"></i>
  <a href="/blog/posts/python-library/">Python Library</a>
  <br>
  
  <i class="fas fa-paperclip"></i>
  <a href="/blog/posts/python-note/">Python Note</a>
  <br>
  
  <i class="fas fa-paperclip"></i>
  <a href="/blog/posts/novel-python/">使用Python爬虫爬取网络小说</a>
  <br>
  
</div>


  <div class="comments">



  <div class="comments-item" >
    
    
    
    <div id="vcomments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <script type="text/javascript">
      new Valine({
          el: '#vcomments',
          highlight: false,
          lang: "en",
          appId: "O9aoAtFO2Mk0VrPqbyHMHwah-gzGzoHsz",
          appKey: "1bF6m0SPiN3sk9TaGxPELdjY",
          placeholder: "Say Something......",
          requiredFields: ["nick","mail"],
          avatar: "robohash",
          visitor:  true ,
          recordIP: true
      });
    </script>
    <script>
      if(window.location.hash){
          var checkExist = setInterval(function() {
             if ($(window.location.hash).length) {
                $('html, body, article').animate({scrollTop: $(window.location.hash).offset().top-90}, 1000);
                clearInterval(checkExist);
             }
          }, 100);
      }
    </script>
  </div>

</div>

</article>



  
  
  
</body>
<div class="foot">
  
  
    &copy; 2017 - 2021 &#183; 
    <a href="/">imlauzh</a> · Theme <a href="https://github.com/RainerChiang/simpleness">Simpleness</a> Powered by <a href="https://gohugo.io/">Hugo</a> &#183;
    <a href="#"><i class="fas fa-chevron-up"></i></a>
  

  
</div>

<script src="/blog/js/lazyload.min.js"></script>
<script>
  var lazyImage = new LazyLoad({
    container: document.getElementById('article')
  });
</script>


</html>
