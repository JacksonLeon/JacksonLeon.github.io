<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Leetcode 654. Maximum Binary Tree | GeekJoe</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/post/">Posts</a></li>
      
      <li><a href="/note/">Notes</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Leetcode 654. Maximum Binary Tree</span></h1>

<h2 class="date">2018/03/24</h2>
</div>

<main>
<h3 id="description">Description</h3>
<blockquote>
<p>Given an integer array with no duplicates. A maximum tree building on this array is defined as follow: The root is the maximum number in the array. The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number. Construct the maximum tree by the given array and output the root node of this tree.</p>
</blockquote>
<!-- raw HTML omitted -->
<h3 id="example">Example</h3>
<pre><code>Input: [3,2,1,6,0,5]
Output: return the tree root node representing the following tree:

      6
    /   \
   3     5
    \   / 
     2 0   
      \
       1
</code></pre><h3 id="note">Note</h3>
<ul>
<li>The size of the given array will be in the range [1,1000].</li>
</ul>
<h3 id="solutions">Solutions</h3>
<h4 id="c-from-discuss--c-on-solutionhttpsleetcodecomproblemsmaximum-binary-treediscuss106146">C++ from Discuss : <a href="https://leetcode.com/problems/maximum-binary-tree/discuss/106146/">C++ O(N) solution</a></h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Definition for a binary tree node.
</span><span style="color:#75715e"> * struct TreeNode {
</span><span style="color:#75715e"> *     int val;
</span><span style="color:#75715e"> *     TreeNode *left;
</span><span style="color:#75715e"> *     TreeNode *right;
</span><span style="color:#75715e"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span><span style="color:#75715e"> * };
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    TreeNode<span style="color:#f92672">*</span> constructMaximumBinaryTree(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">&amp;</span> nums) {
        vector<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*</span><span style="color:#f92672">&gt;</span> mbt;  <span style="color:#75715e">//堆栈存储数组
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>nums.size();i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)  <span style="color:#75715e">//从左到右扫描数组
</span><span style="color:#75715e"></span>        {
            TreeNode<span style="color:#f92672">*</span> cur<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> TreeNode(nums[i]);    <span style="color:#75715e">//当前数初始化树节点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>mbt.empty()<span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span>mbt.back()<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>val<span style="color:#f92672">&lt;</span>nums[i])
            {   <span style="color:#75715e">/*当堆栈不空且新数比堆栈中最后的数字小时，
</span><span style="color:#75715e">                当前节点作为父节点，先前的作为左子树
</span><span style="color:#75715e">                */</span>
                cur<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>left<span style="color:#f92672">=</span>mbt.back();
                mbt.pop_back();
            }
            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>mbt.empty())    <span style="color:#75715e">//正常情况新节点直接作为右子树
</span><span style="color:#75715e"></span>                mbt.back()<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>right<span style="color:#f92672">=</span>cur;
            mbt.push_back(cur);
        }
        <span style="color:#66d9ef">return</span> mbt.front(); <span style="color:#75715e">//返回头节点
</span><span style="color:#75715e"></span>    }
};
</code></pre></div><h4 id="hints">Hints</h4>
<ul>
<li>从左向右直接扫描数组</li>
<li>遇到比上一节点的val值小的直接作为右子树的头节点</li>
<li>所以比较适合使用堆栈来存储数组</li>
<li>当遇到比堆栈back()大的，作为其父节点</li>
<li>过几天再重新写试试看能不能写出来</li>
<li>就这样</li>
</ul>
<h4 id="python-递归">Python 递归</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">constructMaximumBinaryTree</span>(self, nums):
        <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;&#34;&#34;</span><span style="color:#e6db74"></span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">        :type nums: List[int]</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">        :rtype: TreeNode</span><span style="color:#e6db74">
</span><span style="color:#e6db74"></span><span style="color:#e6db74">        </span><span style="color:#e6db74">&#34;&#34;&#34;</span>
        <span style="color:#66d9ef">if</span> nums:
            pos<span style="color:#f92672">=</span>nums<span style="color:#f92672">.</span>index(max(nums))
            root<span style="color:#f92672">=</span>TreeNode(nums[pos])
            root<span style="color:#f92672">.</span>left<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>constructMaximumBinaryTree(nums[:pos])
            root<span style="color:#f92672">.</span>right<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>constructMaximumBinaryTree(nums[pos<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:])
            <span style="color:#66d9ef">return</span> root
</code></pre></div><h4 id="hints-1">Hints</h4>
<ul>
<li>先找到最大的数赋值给root节点</li>
<li>接着递归将左边数组返回左子树的头节点</li>
<li>相同地对右子树进行操作</li>
</ul>

</main>

  <footer>
  <script src="//yihui.name/js/math-code.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script async src="//yihui.name/js/center-img.js"></script>
  
  <hr/>
  © <a href="https://imlauzh.github.io">Joseph Lau</a> 2017 &ndash; 2019 | <a href="https://github.com/imlauzh">Github</a>
  
  </footer>
  </body>
</html>

