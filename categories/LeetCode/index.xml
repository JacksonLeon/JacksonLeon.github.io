<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on GeekJoe</title>
    <link>//localhost:1313/categories/leetcode/</link>
    <description>Recent content in LeetCode on GeekJoe</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 30 Jul 2018 19:58:46 +0000</lastBuildDate>
    
	<atom:link href="//localhost:1313/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 627. Swap Salary</title>
      <link>//localhost:1313/note/leetcode-627.-swap-salary/</link>
      <pubDate>Mon, 30 Jul 2018 19:58:46 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-627.-swap-salary/</guid>
      <description>&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;p&gt;Given a table &lt;code&gt;salary&lt;/code&gt;, such as the one below, that has m=male and f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update query and no intermediate temp table.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After running your query, the above salary table should have the following rows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Leetcode 876. Middle of the Linked List</title>
      <link>//localhost:1313/note/leetcode-876.-middle-of-the-linked-list/</link>
      <pubDate>Mon, 30 Jul 2018 18:59:07 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-876.-middle-of-the-linked-list/</guid>
      <description>&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a non-empty, singly linked list with head node &lt;code&gt;head&lt;/code&gt;, return a middle node of linked list.&lt;/p&gt;
&lt;p&gt;If there are two middle nodes, return the second middle node.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Leetcode 852. Peak Index in a Mountain Array</title>
      <link>//localhost:1313/note/leetcode-852.-peak-index-in-a-mountain-array/</link>
      <pubDate>Mon, 30 Jul 2018 18:31:11 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-852.-peak-index-in-a-mountain-array/</guid>
      <description>&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Let&amp;rsquo;s call an array &lt;code&gt;A&lt;/code&gt; a &lt;em&gt;mountain&lt;/em&gt; if the following properties hold:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;A.length &amp;gt;= 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;There exists some &lt;code&gt;0 &amp;lt; i &amp;lt; A.length - 1&lt;/code&gt; such that &lt;code&gt;A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given an array that is definitely a mountain, return any &lt;code&gt;i&lt;/code&gt; such that &lt;code&gt;A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1]&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Leetcode 617. Merge Two Binary Trees</title>
      <link>//localhost:1313/note/leetcode-617.-merge-two-binary-trees/</link>
      <pubDate>Mon, 30 Jul 2018 16:09:21 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-617.-merge-two-binary-trees/</guid>
      <description>&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.&lt;/p&gt;
&lt;p&gt;You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>LeetCode Analysis</title>
      <link>//localhost:1313/post/leetcode-analysis/</link>
      <pubDate>Mon, 30 Jul 2018 16:09:21 +0000</pubDate>
      
      <guid>//localhost:1313/post/leetcode-analysis/</guid>
      <description>LeetCode Analysis    LeetCode ID Name Status Difficulty Language     191 Number of 1 Bits Solved E C/C++   386 Lexicographical Numbers Solved M C/C++   387 First Unique Character in a String Solved E C/C++   461 Hamming Distance Solved E C/C++   535 Encode and Decode TinyURL Solved M C/C++   595 Big Countries Solved E C/C++   617 Merge Two Binary Trees Solved E C/C++   627 Swap Salary Solved E MySQL   654 Maximum Binary Tree Solved M C/C++   657 Judge Route Circle Solved E C/C++   709 To Lower Case Solved E C/C++   771 Jewels and Stones Solved E C/C++   804 Unique Morse Code Words Solved E C/C++   807 Max Increase to Keep City Skyline Solved M C/C++   832 Flipping an Image Solved E C/C++   852 Peak Index in a Mountain Array Solved E C/C++   876 Middle of the Linked List Solved E C/C++    </description>
    </item>
    
    <item>
      <title>Leetcode 832. Flipping an Image</title>
      <link>//localhost:1313/note/leetcode-832.-flipping-an-image/</link>
      <pubDate>Sun, 15 Jul 2018 18:53:14 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-832.-flipping-an-image/</guid>
      <description>&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.
To flip an image horizontally means that each row of the image is reversed.  For example, flipping &lt;code&gt;[1, 1, 0]&lt;/code&gt; horizontally results in &lt;code&gt;[0, 1, 1]&lt;/code&gt;.
To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting &lt;code&gt;[0, 1, 1]&lt;/code&gt; results in &lt;code&gt;[1, 0, 0]&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Leetcode 709. To Lower Case</title>
      <link>//localhost:1313/note/leetcode-709.-to-lower-case/</link>
      <pubDate>Sat, 14 Jul 2018 10:15:53 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-709.-to-lower-case/</guid>
      <description>&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Leetcode 657. Judge Route Circle</title>
      <link>//localhost:1313/note/leetcode-657.-judge-route-circle/</link>
      <pubDate>Mon, 09 Apr 2018 16:19:57 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-657.-judge-route-circle/</guid>
      <description>&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.
The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are &lt;code&gt;R&lt;/code&gt; (Right), &lt;code&gt;L&lt;/code&gt; (Left), &lt;code&gt;U&lt;/code&gt; (Up) and &lt;code&gt;D&lt;/code&gt; (down). The output should be true or false representing whether the robot makes a circle.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Leetcode 387. First Unique Character in a String</title>
      <link>//localhost:1313/note/leetcode-387.-first-unique-character-in-a-string/</link>
      <pubDate>Mon, 09 Apr 2018 14:56:23 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-387.-first-unique-character-in-a-string/</guid>
      <description>&lt;h3 id=&#34;description&#34;&gt;Description&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a string, find the first non-repeating character in it and return it&amp;rsquo;s index. If it doesn&amp;rsquo;t exist, return -1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;s = &amp;quot;leetcode&amp;quot;
return 0.

s = &amp;quot;loveleetcode&amp;quot;,
return 2.
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You may assume the string contain only lowercase letters.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Leetcode 386. Lexicographical Numbers</title>
      <link>//localhost:1313/note/leetcode-386.-lexicographical-numbers/</link>
      <pubDate>Mon, 26 Mar 2018 15:04:22 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-386.-lexicographical-numbers/</guid>
      <description>Description  Given an integer n, return 1-n in lexicographical order. For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9]. Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.
 Solution class Solution {public:vector&amp;lt;int&amp;gt; lexicalOrder(int n) {vector&amp;lt;int&amp;gt; res;int cur=1;for(int i=1;i&amp;lt;=n;i++){res.push_back(cur);if(cur*10&amp;lt;=n) //首先判断能否直接再后面加0 cur*=10;else if(cur%10!=9&amp;amp;&amp;amp;(cur+1)&amp;lt;=n) //正常情况下+1 cur++;else{while((cur/10)%10==9) //处理*9_的情况，例如192(n=192)的下一个应该是(1__开头结束)2开头，而不是20 {cur/=10;}cur=(cur/10)+1; //这一轮个位结束，从上一位+1继续开始 } }return res;}};Hints  字典排序(数字)</description>
    </item>
    
    <item>
      <title>Leetcode 807. Max Increase to Keep City Skyline</title>
      <link>//localhost:1313/note/leetcode-807.-max-increase-to-keep-city-skyline/</link>
      <pubDate>Sun, 25 Mar 2018 19:12:34 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-807.-max-increase-to-keep-city-skyline/</guid>
      <description>Description  In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. At the end, the &amp;ldquo;skyline&amp;rdquo; when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid.</description>
    </item>
    
    <item>
      <title>Leetcode 804. Unique Morse Code Words</title>
      <link>//localhost:1313/note/leetcode-804.-unique-morse-code-words/</link>
      <pubDate>Sun, 25 Mar 2018 14:04:15 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-804.-unique-morse-code-words/</guid>
      <description>Description  International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: &amp;quot;a&amp;quot; maps to &amp;quot;.-&amp;quot;, &amp;quot;b&amp;quot; maps to &amp;quot;-...&amp;quot;, &amp;quot;c&amp;quot; maps to &amp;quot;-.-.&amp;quot;, and so on.
  For convenience, the full table for the 26 letters of the English alphabet is given below:
 [&amp;quot;.-&amp;quot;,&amp;quot;-...&amp;quot;,&amp;quot;-.-.&amp;quot;,&amp;quot;-..&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;..-.&amp;quot;,&amp;quot;--.&amp;quot;,&amp;quot;....&amp;quot;,&amp;quot;..&amp;quot;,&amp;quot;.---&amp;quot;,&amp;quot;-.-&amp;quot;,&amp;quot;.-..&amp;quot;,&amp;quot;--&amp;quot;,&amp;quot;-.&amp;quot;,&amp;quot;---&amp;quot;,&amp;quot;.--.&amp;quot;,&amp;quot;--.-&amp;quot;,&amp;quot;.-.&amp;quot;,&amp;quot;...&amp;quot;,&amp;quot;-&amp;quot;,&amp;quot;..-&amp;quot;,&amp;quot;...-&amp;quot;,&amp;quot;.--&amp;quot;,&amp;quot;-..-&amp;quot;,&amp;quot;-.--&amp;quot;,&amp;quot;--..&amp;quot;] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter.</description>
    </item>
    
    <item>
      <title>Leetcode 191. Number of 1 Bits</title>
      <link>//localhost:1313/note/leetcode-191.-number-of-1-bits/</link>
      <pubDate>Sun, 25 Mar 2018 13:32:38 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-191.-number-of-1-bits/</guid>
      <description>Description  Write a function that takes an unsigned integer and returns the number of 1 bits it has (also known as the Hamming weight). For example, the 32-bit integer 11 has binary representation 00000000000000000000000000001011, so the function should return 3.
 Solutions  Hamming Weight  class Solution {public:int hammingWeight(uint32_t n) {int c=0;while(n){c++;n&amp;amp;=n-1; //逐次获取最低非0 bit位 }return c;}}; Bit Mask  class Solution(object):def hammingWeight(self, n):&amp;#34;&amp;#34;&amp;#34;:type n: int:rtype: int&amp;#34;&amp;#34;&amp;#34;res=0mask=1for i in range(32):if n&amp;amp;mask: # &amp;amp;：按位与 res+=1mask=mask&amp;lt;&amp;lt;1# n=n&amp;gt;&amp;gt;1 #n移位或者mask移位 return res</description>
    </item>
    
    <item>
      <title>Leetcode 461. Hamming Distance</title>
      <link>//localhost:1313/note/leetcode-461.-hamming-distance/</link>
      <pubDate>Sun, 25 Mar 2018 12:19:52 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-461.-hamming-distance/</guid>
      <description>Description  The Hamming distance between two integers is the number of positions at which the corresponding bits are different.Given two integers x and y, calculate the Hamming distance.
 Example Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0)↑ ↑The above arrows point to positions where the corresponding bits are different.Note  0 ≤ x , y &amp;lt; 2^31</description>
    </item>
    
    <item>
      <title>Leetcode 654. Maximum Binary Tree</title>
      <link>//localhost:1313/note/leetcode-654.-maximum-binary-tree/</link>
      <pubDate>Sat, 24 Mar 2018 23:35:37 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-654.-maximum-binary-tree/</guid>
      <description>Description  Given an integer array with no duplicates. A maximum tree building on this array is defined as follow: The root is the maximum number in the array. The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number. Construct the maximum tree by the given array and output the root node of this tree.</description>
    </item>
    
    <item>
      <title>Leetcode 771. Jewels and Stones</title>
      <link>//localhost:1313/note/leetcode-771.-jewels-and-stones/</link>
      <pubDate>Thu, 22 Mar 2018 15:11:00 +0000</pubDate>
      
      <guid>//localhost:1313/note/leetcode-771.-jewels-and-stones/</guid>
      <description>Desciption  You&amp;rsquo;re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so &amp;ldquo;a&amp;rdquo; is considered a different type of stone from &amp;ldquo;A&amp;rdquo;.</description>
    </item>
    
  </channel>
</rss>